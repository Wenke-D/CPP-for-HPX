(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{430:function(t,e,s){"use strict";s.r(e);var a=s(62),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"exercise-my-advance"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#exercise-my-advance"}},[t._v("#")]),t._v(" Exercise: "),s("code",[t._v("my::advance")])]),t._v(" "),s("p",[t._v("Please recall, in the previous chapter, we used the smart function "),s("code",[t._v("std::advance")]),t._v(" which advances an iterator intelligently based on the input iterator. If the iterator is a random access iterator, it will use jump operation, otherwise it will use increment operation. Now we have enough knowledge to write one by ourselves.")]),t._v(" "),s("p",[t._v("Same as the previous chapter, we define all the functions and classes under the namespace "),s("code",[t._v("my")]),t._v(".")]),t._v(" "),s("p",[t._v("Intuitively, to write the "),s("code",[t._v("advance")]),t._v(", we should be able to do 2 things:")]),t._v(" "),s("ul",[s("li",[t._v("Distinguishing random access iterators from others")]),t._v(" "),s("li",[t._v("Then perform the right operation.")])]),t._v(" "),s("h2",{attrs:{id:"iterator-tag"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#iterator-tag"}},[t._v("#")]),t._v(" Iterator Tag")]),t._v(" "),s("p",[t._v("Firstly, let's write a type traits which distinguish random access iterator. It returns "),s("code",[t._v("true_type")]),t._v(" if the argument is a random access iterator, otherwise returns "),s("code",[t._v("false_type")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Iter")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("is_random_access_iterator0")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token base-clause"}},[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("if_")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("is_same")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("iterator_traits")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Iter")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("iterator_category")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("random_access_iterator_tag")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("true_type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("false_type")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("p",[t._v("We named it "),s("code",[t._v("is_random_access_iterator0")]),t._v(" because we will simply it later. This type traits have "),s("code",[t._v("Iter")]),t._v(" as the argument and tells us whether "),s("code",[t._v("Iter")]),t._v(" is a random access iterator.")]),t._v(" "),s("p",[t._v("This looks intimidating, but don't worry, let's take it down piece by piece. Essentially it's a template class which has a empty body and which inherits a "),s("strong",[t._v("type")]),t._v(" that presented by the following big expression (line 3 ~ 9). So, we only need to figure out what is the big type.")]),t._v(" "),s("p",[t._v("The first layer of the big type is the meta function "),s("code",[t._v("if_<bool, T1, T2>")]),t._v(" which we defined in the last chapter. Here "),s("code",[t._v("T1")]),t._v(" is "),s("code",[t._v("true_type")]),t._v(" and "),s("code",[t._v("T2")]),t._v(" is "),s("code",[t._v("false_type")]),t._v(" respectively, and everything between is just a bool expression. So that is to say, when the "),s("code",[t._v("bool")]),t._v(" is "),s("code",[t._v("true")]),t._v(", the "),s("code",[t._v("is_random_access_iterator")]),t._v(" will inherit "),s("code",[t._v("true_type")]),t._v(", otherwise it inherit "),s("code",[t._v("false_type")]),t._v(". So all we need to know is when the "),s("code",[t._v("bool")]),t._v(" is "),s("code",[t._v("true")]),t._v(" ?")]),t._v(" "),s("p",[s("code",[t._v("is_same<T1, T2>")]),t._v(" is another type traits which checks whether "),s("code",[t._v("T1")]),t._v(" equals to "),s("code",[t._v("T2")]),t._v(" or not. In our case, "),s("code",[t._v("T1")]),t._v(" is "),s("code",[t._v("std::iterator_traits<Iter>::iterator_category")]),t._v(", this is another type traits which returns the category of an iterator. The keyword "),s("code",[t._v("typename")]),t._v(" tells the compiler that this is a type instead of a value. The category of the random access iterator named "),s("code",[t._v("std::random_access_iterator_tag")]),t._v(", that's why we put it as "),s("code",[t._v("T2")]),t._v(". So "),s("code",[t._v("is_same<..., ...>")]),t._v(" will be "),s("code",[t._v("true_type")]),t._v(" when "),s("code",[t._v("Iter")]),t._v(" is the random access iterator. Furthermore, by accessing its value, the whole "),s("code",[t._v("bool")]),t._v(" of the "),s("code",[t._v("if_<bool, ..., ...>")]),t._v(" will be "),s("code",[t._v("true")]),t._v(" when "),s("code",[t._v("Iter")]),t._v(" is the random access iterator.")]),t._v(" "),s("p",[t._v("Combining everything together, we've got what we want. When "),s("code",[t._v("Iter")]),t._v(" is a random access iterator, the type traits "),s("code",[t._v("is_random_access_iterator0")]),t._v(" inherits "),s("code",[t._v("true_type")]),t._v(", otherwise inherits "),s("code",[t._v("false_type")]),t._v(". Now, we can use it to check the property of the iterator.")]),t._v(" "),s("p",[t._v("Do some of you see a little bit redundance here? That's very true. "),s("code",[t._v("is_same")]),t._v(" returns "),s("code",[t._v("true_type")]),t._v(" and "),s("code",[t._v("false_type")]),t._v(" too, we don't need a "),s("code",[t._v("if_")]),t._v(" wrapped it.")]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Iter")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("is_random_access_iterator")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token base-clause"}},[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("is_same")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("iterator_traits")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Iter")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("iterator_category")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n              std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("random_access_iterator_tag")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("This is the type traits we need to distinguish random access iterator from others.")]),t._v(" "),s("h2",{attrs:{id:"type-dispatch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#type-dispatch"}},[t._v("#")]),t._v(" Type Dispatch")]),t._v(" "),s("p",[t._v("Now we need to use the proper operation depending on the iterator, and the choice must be done at compile time.")]),t._v(" "),s("div",{staticClass:"language-cpp line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// for other iterators")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Iter")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("advance")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Iter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("iter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" false_type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        iter"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// for random access iterators")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Iter")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("advance")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Iter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("iter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" true_type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    iter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// the main function")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Iter")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("advance")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Iter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("iter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("advance")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("iter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("is_random_access_iterator")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Iter"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")])])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br")])]),s("p",[t._v("Here, we used a technique called type dispatch. The entrance of the third one, use can call it with a iterator and a number representing the step. Then to select the right function at compile time, we overloaded this function. The other 2 functions take the third argument, which is "),s("code",[t._v("true_type")]),t._v(" and "),s("code",[t._v("false_type")]),t._v(" respectively. Once the traits gives us an answer, one function will be called depending on the answer. One tricky thing is the parenthesis right after the traits. It's a construction, we construct an anonymous "),s("code",[t._v("true_type")]),t._v(" or "),s("code",[t._v("false_type")]),t._v(", then the compiler will use the function overloading to choose the function. Since "),s("code",[t._v("true_type")]),t._v(" and "),s("code",[t._v("false_type")]),t._v(" are anonymous parameter in the first two function and they are not used, the overhead of the object construction will be optimized away by the compiler.")])])}),[],!1,null,null,null);e.default=n.exports}}]);