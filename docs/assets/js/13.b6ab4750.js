(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{424:function(t,e,a){"use strict";a.r(e);var s=a(62),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"template-meta-programing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#template-meta-programing"}},[t._v("#")]),t._v(" Template Meta Programing")]),t._v(" "),a("p",[t._v("In the previous chapter, we presented the template system of C++, including template function and template class. About the template class, we implemented one named "),a("code",[t._v("coordinated<T>")]),t._v(". In this chapter we gonna still focus on template class.")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("coordinate")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" T x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("This usage is what the template class was invented for, defining types based on various generic type, so that we could use it in different contexts. Almost every standard container, such as "),a("code",[t._v("std::vector")]),t._v(", "),a("code",[t._v("std::list")]),t._v(", is parametrizable with template type.")]),t._v(" "),a("p",[t._v("The template become a C++ standard at 1998. Then a guy found something that template was not designed for. He discovered that template system is "),a("strong",[t._v("Turing-Complete")]),t._v(". Loosely speaking, Turing-completeness means a system has the minimum set of necessary operations allowing the system to perform universal computation. The fact that template is turing complete means one can perform computation at compile time.")]),t._v(" "),a("p",[t._v("This was surprising at that moment. That guy showed a program which printed prime numbers in the compiler generated error message during compile time, then the program failed to be compiled (which proved that the computation really happened at compile time). We call programing at compile time: "),a("strong",[t._v("template meta programing")]),t._v("(TMP). This was the starting point of template meta programing ,and it completely went off today. One usage of the template meta-programing is the code generation during compile time, whose examples have been shown in previous chapters.")]),t._v(" "),a("p",[t._v("At this chapter, as many examples we gonna use have a counterpart with the same name in standard template library under the namespace "),a("code",[t._v("std")]),t._v(", we will put our example under the namespace "),a("code",[t._v("my")]),t._v(" to distinguish from them.")]),t._v(" "),a("h2",{attrs:{id:"meta-function"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#meta-function"}},[t._v("#")]),t._v(" Meta Function")]),t._v(" "),a("p",[t._v("First of all, let's see how to define and call functions in TMP. We will show a simple example of numerical computation, "),a("strong",[t._v("factorial")]),t._v(" calculation at compile time. For illustration purpose, we gonna do it in the old way (before C++11), some modern C++ features can simplify it, we will talk about them later.")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" N"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("factorial")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" N "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" factorial"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("N "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// template specialization")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("factorial")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("We defined a template class named "),a("code",[t._v("factorial")]),t._v(". It takes an integer as template parameter instead of a type (line 1). This is valid, C++ allows us declaring "),a("code",[t._v("integer")]),t._v(", "),a("code",[t._v("long")]),t._v(", "),a("code",[t._v("bool")]),t._v(" etc... as template parameter. So, for each integer argument, we will have a different type. For instances, "),a("code",[t._v("factorial<1>")]),t._v(" and "),a("code",[t._v("factorial<2>")]),t._v(" are 2 "),a("strong",[t._v("independent")]),t._v(" types. This allows us encoding integers into types.")]),t._v(" "),a("p",[t._v("As result, we can use types to represent integers, and this is the basis for computation at compile time. Because the compiler can't do input, output nor assign variable. All we can do is to generate types as variables so that we could program. Since we can't change type, the variable is immutable. This feels like functional programing(FP), as we can't change the value of a variable in FP either.")]),t._v(" "),a("p",[t._v("This is exactly how we are going to use template for computation. Whenever we need a new variable, we create a new type represent that variable. So calculating factorial is essentially creating a sequence of types representing each factorial when the factorial is unfolded recursively. So each time we multiple, we create a new type as the operand.")]),t._v(" "),a("p",[t._v("In term of syntax, this is a template class, but we use it as a function. So we call it "),a("strong",[t._v("meta function")]),t._v(", meta means that it runs at compile time. Now we can define parameters and pass arguments to it. But what is the return value of that function ? People have come up a pure convention for return value. For a meta function for numerical computation, we will "),a("strong",[t._v("always")]),t._v(" define a "),a("code",[t._v("static")]),t._v(" member called "),a("code",[t._v("value")]),t._v(" and make it "),a("code",[t._v("const")]),t._v(" as a variable. In our case, the return value is integer, so the "),a("code",[t._v("value")]),t._v(" is of type "),a("code",[t._v("int")]),t._v(". We get the return value of the meta function by access this member, for example "),a("code",[t._v("10!")]),t._v(" is "),a("code",[t._v("factorial<10>::value")]),t._v(". As it's a convention, whenever seeing a template class with a "),a("code",[t._v("value")]),t._v(" as its member, we could just assume the template class is meta function for numerical operations.")]),t._v(" "),a("h2",{attrs:{id:"branch-and-specialization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#branch-and-specialization"}},[t._v("#")]),t._v(" Branch and Specialization")]),t._v(" "),a("p",[t._v("So in the body of the meta function, we use "),a("code",[t._v("N * factorial <N-1>::value")]),t._v(" to recursively calculate the factorial of N. But this is not enough, we need to find a way to stop at "),a("code",[t._v("1!")]),t._v(", otherwise the compilation will never stop. In another world, we need to be able to make decision, so we need some thing like a "),a("code",[t._v("if")]),t._v(" statement.")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" N"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("factorial")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" N "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" factorial"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("N "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// template specialization")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("factorial")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("This is done by "),a("strong",[t._v("template specialization")]),t._v(" (line 6).\nIn addition to the main template, we supply another specialization of the template which will be used when the integer argument is equal to 1. Whenever we use "),a("code",[t._v("factorial<1>")]),t._v(", the compile will not use the main template but the specialization. This give us a break point, it will go down till N is equal to 1 and then go back to give us the final result.")]),t._v(" "),a("p",[t._v("It's called specialization, because we provide special templates for one or more template arguments. For all other value, the compile still chooses the original template. We can provide as many template specializations as we want. The compile performs the pattern matching to find the one best matching the argument.")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("For some of you know functional programing, this is very similar to the following "),a("code",[t._v("ocaml")]),t._v(" code.")]),t._v(" "),a("div",{staticClass:"language-ocaml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ocaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("rec")]),t._v(" factorial n "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("match")]),t._v(" n "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("with")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" factorial "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";;")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])])]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("    cout "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" my"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("factorial"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("endl"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")])])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"})]),a("p",[t._v("This is how we call the function in our code. After the compilation, the factorial<10>::value will become 3628800.")]),t._v(" "),a("p",[t._v("For some of you who doubt that this is really happening at compile time? We can check the generated assembly code. The argument for g++ to generate assembly code is "),a("code",[t._v("-S")]),t._v(".")]),t._v(" "),a("div",{staticClass:"language-armasm line-numbers-mode"},[a("div",{staticClass:"highlight-lines"},[a("br"),a("br"),a("div",{staticClass:"highlighted"},[t._v("Â ")]),a("br"),a("br"),a("br")]),a("pre",{pre:!0,attrs:{class:"language-armasm"}},[a("code",[t._v("\tmovl\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("edi"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("rbp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tmovq\t"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("rsi"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("rbp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tmovl\t"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$3628800")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("esi\n\tleaq\t_ZSt4cout"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("rip"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("rdi\n\tcall\t_ZNSolsEi@PLT\n")])]),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("In our case, we can see there is no loop nor multiplication, the result is directly written in the assembly code (line 3).")]),t._v(" "),a("p",[t._v("Template specialization is very powerful and we will use it over and over again. Besides, there are some limitation on the template argument. As we said, "),a("code",[t._v("int")]),t._v(", "),a("code",[t._v("long")]),t._v(", "),a("code",[t._v("bool")]),t._v(" etc... can be template parameters, but we can't declare real numbers as template parameter, including "),a("code",[t._v("float")]),t._v(", "),a("code",[t._v("double")]),t._v(" and their variants. Because they are not complete type, some numbers can't be represented precisely. Since the compiler use pattern matching to choose the template, we can't use have some template that may or may not be chosen. But nowadays, with "),a("code",[t._v("constexpr")]),t._v(" (C++11), this becomes possible too, so a full complete programing at compile time. We will talk about it in detail in the future.")]),t._v(" "),a("h2",{attrs:{id:"type-computation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#type-computation"}},[t._v("#")]),t._v(" Type Computation")]),t._v(" "),a("p",[t._v("Another thing we can do with meta function is type computation. Instead of calculations of some values, meta function can return a type.")]),t._v(" "),a("p",[t._v("In certain scenarios, if we have a type, we want have its pointer type, such as getting "),a("code",[t._v("int*")]),t._v(" from "),a("code",[t._v("int")]),t._v(". And we want that happened at compile time. We used some of these techniques in HPX. Because HPX is a very generic library. For example, "),a("code",[t._v("hpx::asnyc()")]),t._v(" can work with arbitrary argument. Under the hood, there are a lot of type computations, so that it can run the right code depending on the input type.")]),t._v(" "),a("h3",{attrs:{id:"adding-pointer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#adding-pointer"}},[t._v("#")]),t._v(" adding pointer")]),t._v(" "),a("p",[t._v("The first example is a meta function which takes a type "),a("code",[t._v("T")]),t._v(" as argument and generate the type "),a("code",[t._v("T*")]),t._v(".")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("add_pointer")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" T "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("According to the convention, when a meta function is for type computation, the member for return value will be named "),a("code",[t._v("type")]),t._v(".")]),t._v(" "),a("p",[t._v("As you can see , obviously when we have a T as argument, the return value of this function is T*.")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("    my"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("add_pointer"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("type x1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")])])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"})]),a("p",[t._v("The type of variable "),a("code",[t._v("x")]),t._v(" is "),a("code",[t._v("int*")]),t._v(" instead of "),a("code",[t._v("int")]),t._v(".\nAlso, one can use "),a("code",[t._v("typeid")]),t._v(" keyword to retrieve information from a type.")]),t._v(" "),a("h3",{attrs:{id:"making-map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#making-map"}},[t._v("#")]),t._v(" making map")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("K")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("V")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("make_map")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("map"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("K"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" V"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")])])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("This meta function returns a concrete map type based on template argument.")]),t._v(" "),a("h3",{attrs:{id:"removing-pointer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#removing-pointer"}},[t._v("#")]),t._v(" removing pointer")]),t._v(" "),a("p",[t._v("We had a "),a("code",[t._v("add_pointer")]),t._v(", how about "),a("code",[t._v("remove_pointer")]),t._v(" which removes the star if the type is a pointer.")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("remove_pointer")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" T type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("remove_pointer")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" T type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")])])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("This meta function, here we still need a condition to check whether the argument is a pointer type or, so we need template specialization.")]),t._v(" "),a("h3",{attrs:{id:"no-pointer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#no-pointer"}},[t._v("#")]),t._v(" no pointer")]),t._v(" "),a("p",[t._v("How about a "),a("code",[t._v("no_pointer")]),t._v(", which removes all stars on a type recursively.")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("no_pointer")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" T type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("no_pointer")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("my_no_pointer")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("type type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")])])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("Here we applied the same technique as the factorial. we call the specialized meta function recursively as long as there is at least a star. Then we jump out the recursion by the main template.")]),t._v(" "),a("p",[t._v("One thing we need to notice is the keyword "),a("code",[t._v("typename")]),t._v(", it hint the compile that the following expression is a type not a value, because in some cases, the compiler can't distinguish them. The compiler nowadays is good enough to tell if its needs that keyword or not.")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("my"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("no_pointer"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("type x3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nmy"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("no_pointer"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("type x4"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")])])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[a("code",[t._v("x3")]),t._v(" and "),a("code",[t._v("x4")]),t._v(" are of type "),a("code",[t._v("int")]),t._v(" and "),a("code",[t._v("double")]),t._v(" respectively.")]),t._v(" "),a("p",[t._v("So we can do nice type transformation by pattern matching. That is, we can choose template based on our need, and template specialization is really the key to that.")]),t._v(" "),a("h3",{attrs:{id:"partial-specialization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#partial-specialization"}},[t._v("#")]),t._v(" partial specialization")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),t._v(" flag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("if_")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" T1 type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("if_")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" T1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" T2"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" T2 type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")])])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("This meta function returns T1 when flag is true, otherwise returns T2. The main template which will be selected whenever the flag is true. When the flag is false, the specialization will be used. Please notice that the template can be partially specialized. The specialization only specify the "),a("strong",[t._v("first")]),t._v(" parameter of the main template.")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("my"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("if_"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" var1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nmy"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("if_"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" var2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[a("code",[t._v("var1")]),t._v(" is of type "),a("code",[t._v("int")]),t._v(", and "),a("code",[t._v("var2")]),t._v(" is a "),a("code",[t._v("bool")]),t._v(".")]),t._v(" "),a("p",[t._v("We need to emphasize again that all the computations above happened at compile time.")]),t._v(" "),a("h2",{attrs:{id:"true-type-and-false-type"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#true-type-and-false-type"}},[t._v("#")]),t._v(" True Type and False Type")]),t._v(" "),a("p",[t._v("Now we want to introduce 2 facilities that are so useful, that they are in standard now.\nA type representing boolean value "),a("code",[t._v("true")]),t._v(", and one for boolean value "),a("code",[t._v("false")]),t._v(".")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("true_type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" true_type type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("false_type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" false_type type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")])])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("p",[t._v("They are not template, simply structures. They are used to represent "),a("code",[t._v("true")]),t._v(" and "),a("code",[t._v("false")]),t._v(" in the type system. And since we want them to be true meta function, we not only give them a value but also a type as member. For lack of alternative, we just let them return themselves as the type. We can use them both for numerical computation and type computation. As you will see, these small tricks will be used everywhere.")]),t._v(" "),a("h2",{attrs:{id:"type-traits"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#type-traits"}},[t._v("#")]),t._v(" Type Traits")]),t._v(" "),a("p",[t._v("We already have meta functions for the numerical operation and type transformation, We can also have meta function for retrieving information from the type. For instance, the meta function "),a("code",[t._v("is_void<T>")]),t._v(" to check if the "),a("code",[t._v("T")]),t._v(" is "),a("code",[t._v("void")]),t._v(" or not. These special meta function are called "),a("strong",[t._v("type traits")]),t._v(", as they introspect the information of type.")]),t._v(" "),a("p",[t._v("All type traits in standard library return "),a("code",[t._v("std::true_type")]),t._v(" or "),a("code",[t._v("std::false_type")]),t._v(". We are going to show how to write some of them. In our version, it will return "),a("code",[t._v("my::true_type")]),t._v(" or "),a("code",[t._v("my::true_type")]),t._v(".")]),t._v(" "),a("p",[t._v("The first type traits is "),a("code",[t._v("is_pointer<T>")]),t._v(", it checks whether T is a pointer or not.")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("is_pointer")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token base-clause"}},[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("false_type")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("is_pointer")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" true_type "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("Essentially, we are making decision based on input, so the specialization shows itself again. The tricky part is how we gonna return "),a("code",[t._v("true_type")]),t._v(" and "),a("code",[t._v("false_type")]),t._v(". We will use inherence, if "),a("code",[t._v("T")]),t._v(" is a pointer, we gonna return "),a("code",[t._v("true_type")]),t._v(" by deriving the meta function from "),a("code",[t._v("true_type")]),t._v(", otherwise deriving "),a("code",[t._v("false_type")]),t._v(". Whatever "),a("code",[t._v("true_type")]),t._v(" / "),a("code",[t._v("false_type")]),t._v(" have , the "),a("code",[t._v("is_pointer")]),t._v(" will implicitly have it too. The reason this way works, is because essentially the meta funtion is template class.")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("    my"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("is_pointer"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")])])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"})]),a("p",[t._v("The value of the above expression is "),a("code",[t._v("false")]),t._v(".")]),t._v(" "),a("p",[t._v("Here's another example, a type traits takes 2 template types as arguments and check whether they are the same or not.")]),t._v(" "),a("div",{staticClass:"language-cpp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("is_same")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token base-clause"}},[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("false_type")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("is_same")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" true_type "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")])])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("Again, the specialization is used for conditional return, and we use inherence for the return value.")]),t._v(" "),a("p",[t._v("According to the convention, all standard type traits return "),a("code",[t._v("true_type")]),t._v(" or "),a("code",[t._v("false_type")]),t._v(". Hence, next time when you see expressions like "),a("code",[t._v("is_xxx::type")]),t._v(", don't no need to digging in what it is. Because some them could be extremely complex, to query the information of type.\nBut, we can immediately know that it will give "),a("code",[t._v("true_type")]),t._v(" or "),a("code",[t._v("false_type")]),t._v(". So, this is how we build the high level abstraction without understanding what is actually going on, and most of time we even don't want to understanding it because they are fairly trickly.")]),t._v(" "),a("p",[t._v("A funny fact, early days, when Boots invented all these mechanisms, the compiler was weak, old, and not conforming to the standard. As consequences, some implementations of type traits toke advantage of compiler bugs to do its job. They knew for this particular compiler, if we do it that way, it will do exactly what we want and there is no other way.")]),t._v(" "),a("p",[t._v("Type trait are widely used in HPX, for example "),a("code",[t._v("is_execution_policy")]),t._v(", we defined a lot customized ones in HPX to allow us inspecting the type for our own needs.")]),t._v(" "),a("h2",{attrs:{id:"alias-by-typedef"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#alias-by-typedef"}},[t._v("#")]),t._v(" Alias by "),a("code",[t._v("typedef")])]),t._v(" "),a("p",[t._v("C++ has two ways to define type alias, "),a("code",[t._v("typedef")]),t._v(" and "),a("code",[t._v("using")]),t._v(". "),a("code",[t._v("using")]),t._v(" is a more powerful feature.\nHPX uses "),a("code",[t._v("typedef")]),t._v(" for backward compatibility, to support the compiler that doesn't know "),a("code",[t._v("using")]),t._v(". Once we get rid of GCC 4.6, 4.7, we will switch to the new way.")]),t._v(" "),a("p",[t._v("We can't use "),a("code",[t._v("typedef")]),t._v(" to defining template alisa, this is one reason that "),a("code",[t._v("using")]),t._v(" was introduced.")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("The next chapter is an exercise. We gonna write the function "),a("code",[t._v("std::advance")]),t._v(" by ourselves. The exercise will revise all the techniques we've learned before.")])])}),[],!1,null,null,null);e.default=n.exports}}]);