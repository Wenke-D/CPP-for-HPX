<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Template Programing | C++ for HPX</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/CPP-for-HPX/images/logo.png">
    <meta name="description" content="a tutorial of C++ for HPX">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/CPP-for-HPX/assets/css/0.styles.3599561d.css" as="style"><link rel="preload" href="/CPP-for-HPX/assets/js/app.ee480cfc.js" as="script"><link rel="preload" href="/CPP-for-HPX/assets/js/2.c47d8a76.js" as="script"><link rel="preload" href="/CPP-for-HPX/assets/js/12.d5d0a49c.js" as="script"><link rel="prefetch" href="/CPP-for-HPX/assets/js/10.f9b7d4f7.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/11.465437ef.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/13.a6bf5429.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/14.f128e8d0.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/15.76a23777.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/16.c09a5233.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/3.8ee437fd.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/4.9a2e6ff2.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/5.f862fe83.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/6.6e41bdef.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/7.dbf4b476.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/8.c51db3ff.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/9.3f9464bc.js">
    <link rel="stylesheet" href="/CPP-for-HPX/assets/css/0.styles.3599561d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/CPP-for-HPX/" class="home-link router-link-active"><img src="/CPP-for-HPX/images/logo.png" alt="C++ for HPX" class="logo"> <span class="site-name can-hide">C++ for HPX</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/CPP-for-HPX/guide/" class="nav-link router-link-active">
  Guide
</a></div><div class="nav-item"><a href="/CPP-for-HPX/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://hpx-docs.stellar-group.org/latest/html/index.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  HPX
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/CPP-for-HPX/guide/" class="nav-link router-link-active">
  Guide
</a></div><div class="nav-item"><a href="/CPP-for-HPX/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://hpx-docs.stellar-group.org/latest/html/index.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  HPX
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Guide</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/CPP-for-HPX/guide/" aria-current="page" class="sidebar-link">Introduction</a></li><li><a href="/CPP-for-HPX/guide/Chapter01/" class="sidebar-link">Standard Template Library (STL)</a></li><li><a href="/CPP-for-HPX/guide/Chapter02/" aria-current="page" class="active sidebar-link">Template Programing</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/CPP-for-HPX/guide/Chapter02/#more-flexibility-with-iterators" class="sidebar-link">More Flexibility with Iterators</a></li><li class="sidebar-sub-header"><a href="/CPP-for-HPX/guide/Chapter02/#template-function" class="sidebar-link">Template Function</a></li><li class="sidebar-sub-header"><a href="/CPP-for-HPX/guide/Chapter02/#template-class" class="sidebar-link">Template Class</a></li><li class="sidebar-sub-header"><a href="/CPP-for-HPX/guide/Chapter02/#arrow-declaration-and-decltype" class="sidebar-link">Arrow Declaration and decltype</a></li></ul></li><li><a href="/CPP-for-HPX/guide/Chapter03/" class="sidebar-link">Template Meta-programing</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="template-programing"><a href="#template-programing" class="header-anchor">#</a> Template Programing</h1> <p>Last time we discussed iterators, containers and algorithms, and we started to talk about the template function. We defined a template function called <code>my_copy</code> which allow the compiler to generate a real function based on the concrete type at moment of call. The real function copies element by iterators. In the beginning of this chapter we will still use this template function.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">In</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Out</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">my_copy</span><span class="token punctuation">(</span>In begin<span class="token punctuation">,</span> In end<span class="token punctuation">,</span> Out out<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">!=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span>out <span class="token operator">=</span> <span class="token operator">*</span>begin<span class="token punctuation">;</span>
        out<span class="token operator">++</span><span class="token punctuation">;</span>
        begin<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>This was how we called the function</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">my_copy</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="more-flexibility-with-iterators"><a href="#more-flexibility-with-iterators" class="header-anchor">#</a> More Flexibility with Iterators</h2> <p>However, as you may noticed, in the copy function, we assumed the destination has enough place for incoming elements. If destination don't have enough places, the code will crashed. Luckily it's true in our code, we initialized the <code>v2</code> with 10 spaces.</p> <p>This is somehow annoying, as we know, the vector has the ability to grow on demand. Is there anyway we can copy elements to an empty vector and let it grow?
The problem here is, as mentioned in the previous chapter, while algorithms don't know and don't have to know the detail of the container, how we can use ability of containers. The answer is still the same: iterators.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v4<span class="token punctuation">;</span>

<span class="token function">my_copy</span><span class="token punctuation">(</span>v1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>v4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>std::back_inserter</code> is function which takes a container as argument and returns a iterator. When the iterator is dereferenced, it will call the <code>insert</code> / <code>push_back</code> method of the underlying container referred by the iterator. This function doesn't rely on any particular container, it only requires the container has a <code>insert</code> or <code>push_back</code> method. In <code>my_copy</code> function, we use <code>*out = *begin</code> to assign data to the destination container. When <code>out</code> is dereferenced, it will call the <code>insert</code> / <code>push_back</code> of the container to insert the element. So this creates new element in the container as we go and it will make the vector grow as large as we need.</p> <p>We use the example to show that, even the <code>copy</code> is not aware what actually is going inside the container, as all other algorithms defined in the header <code>&lt;algorithms&gt;</code>. All it knows is there is an iterator pointing to a space of a container and it's user's job to make sure the destination container has enough space. None of them know anything about the container, all of them work with element on iterator. If we want to work with containers, we have to get help of iterators, like the one we showed. We use special iterator to manipulate containers.</p> <h2 id="template-function"><a href="#template-function" class="header-anchor">#</a> Template Function</h2> <p>Now, let's write another function to check whether a give word is a <strong>palindrome</strong> or not. A <strong>palindrome</strong> is a sequence of characters which reads the same backward as forward, such as 'madam'.</p> <p>Intuitively, we will need a <code>for</code> loop to check whether each character are equal. But, think twice what we really want to do with the <code>for</code> loop and go check <strong>standard algorithms</strong> library, because we may find what we want there. There are 2 reasons to use a standard algorithm instead of writing one by ourselves.</p> <ol><li>We often get messed up by <code>for</code> loops, especially dealing with ranges, but with <strong>standard algorithms</strong>, the chances are slim.</li> <li>This is main reason. If we can use standard algorithms for something, then making that thing parallel running it on a multiprocessor system, is nothing but to change namespace to <code>std::parallel</code> with the same argument.
That's a huge advantage. Parallelization always has pay back, changing namespace is definitely a small cost as all the standard algorithm have a parallel version.</li></ol> <p>That's why whenever we can use a <strong>standard algorithm</strong>, just go for it.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">is_palindrome</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">equal</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>std::string</code> is also a container, it's very similar to vector with additional characteristic for C-like <code>char</code> type. We can think of <code>std::string</code> as a <code>vector&lt;char&gt;</code>. So we can treat string as the same way as <code>std::vector</code> and apply any standard algorithms on it.</p> <p><code>std::equal</code> takes 2 ranges and sees whether they are equal or not. <code>s.rbegin()</code> points to the last char of the string, when we increase it, it go backwards on the string.</p> <h3 id="faster"><a href="#faster" class="header-anchor">#</a> Faster</h3> <p>We can do it better, we don't have to check the whole string, half of it will be enough. So we need to replace <code>s.end()</code> by an iterator pointing to the middle of the string.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">is_palindrome2</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> middle <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    middle <span class="token operator">+=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">equal</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> middle<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>The keyword <code>auto</code> is a C++ 11 feature, it tells the compiler <em>&quot;Hey, why I have to tell you what type is the assigned variable, you know better than me. It's a some fancy iterator of an container, but I don't really care, just write it for me&quot;</em>. By <code>auto</code>, compiler will <strong>deduce</strong> that type for us, we don't need to explicitly write it out.</p> <p>In our case, <code>std::string</code> is a sequence of char, it spares in the memory space continuously. Obviously the iterator of <code>std::string</code> supports random access operation, we can use <code>i += N</code> on it.</p> <h3 id="more-abstraction"><a href="#more-abstraction" class="header-anchor">#</a> More Abstraction</h3> <p>But if we make our <code>is_palindrome</code> a template function and remove limitation on the container of characters. So the argument could be a vector of char, a list of char, a tree of char and so on. Please recall the hierarchy of iterators, only <strong>random access iterator</strong> supports jump operation. However, in our case, nobody could tell inside the <code>is_palindrome</code> what the category of the passed iterator is. If we use jump directly without check, if the passed container is a list, this fail. because the iter of list doesn't support jump.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Container</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token function">is_palindrome3</span><span class="token punctuation">(</span>Container s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> middle <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">advance</span><span class="token punctuation">(</span>middle<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">equal</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> middle<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Except <code>std::advance</code>. this function advances a iterator by the N step. One would say <em>&quot;we can do increment with a loop for any iterators. Why we need advance ?&quot;</em> There are two reasons:</p> <ul><li>As we said, whenever we can use a standard algorithm, use it.</li> <li>For random access iterators, whey can jump in O(1), it's more efficient.</li></ul> <p><code>std::advance</code> can determine whether it's a random access iterator or not, then increase the iterator in the best way.
Moreover, it checks the category at compile time, then the code of right increment operation will be generated by the compiler. So in the executable, there is no condition before the increment operation. This is power of template, we can generate code depending on our need.</p> <p>We will reveal the magic of <code>std::advance</code> in the next chapter. To understand that, first we need to introduce template class first.</p> <h2 id="template-class"><a href="#template-class" class="header-anchor">#</a> Template Class</h2> <p>We have seem template function and write some by ourselves. But about <code>std::vector</code>, <code>std::list</code> what are they ? They are not template functions, they are types with the generic type.
So C++ has to have facilities allowing us build type with template ,and it's the template class.
Just as the template function is not a real function, the template class is only a recipe to generate class.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">coordinate</span> <span class="token punctuation">{</span> T x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <div class="line-numbers-wrapper"></div></div><p>Here we defined a template class with a generic type <code>T</code>. It has 2 members, x and y of type <code>T</code>. We can use it with float, double, int and so on. It can generate a real coordinate class at compile time depending on the concrete type. For instances:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>coordinate<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> c1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
coordinate<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> c2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
coordinate<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> c3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
coordinate<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> c4 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">6.1</span><span class="token punctuation">,</span> <span class="token number">7.8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>We created a coordinate using <code>int</code> and one using <code>double</code>.</p> <p>Now, let's write a function calculating the distance of 2 coordinates. Of course, in OOP we shall write a member method for that. But, for illustration purpose, let's write it as a function.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">/**
 * Calculates square of arbitrary type
 */</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">auto</span> <span class="token function">sqr</span><span class="token punctuation">(</span>T val<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> val <span class="token operator">*</span> val<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">distance</span><span class="token punctuation">(</span>coordinate<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> c1<span class="token punctuation">,</span> coordinate<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> c2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">sqr</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span>x <span class="token operator">-</span> c2<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">sqr</span><span class="token punctuation">(</span>c2<span class="token punctuation">.</span>y <span class="token operator">-</span> c2<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>What do we see here?</p> <ol><li>We can ask compiler to do partial pattern matching. We limit the argument type, this template function only accepts the call with 2 coordinates which contain the same type.</li> <li>We can declare that generic type as the return type of the function. This means whatever the compiler match as the generic type <code>T</code>, it will be the return type.</li></ol> <p>Here are 2 examples:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> d1 <span class="token operator">=</span> <span class="token function">distance</span><span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> d2 <span class="token operator">=</span> <span class="token function">distance</span><span class="token punctuation">(</span>c3<span class="token punctuation">,</span> c4<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>As you can see, <code>c1</code> and <code>c2</code> are coordinates of <code>int</code>, so the return type of their distance is <code>int</code> as well. And same for <code>c3</code> and <code>c4</code>.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">distance</span><span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// compile error</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>The compiler will complain this line, because <code>c1</code> and <code>c3</code> are not coordinates with the same type.</p> <h2 id="arrow-declaration-and-decltype"><a href="#arrow-declaration-and-decltype" class="header-anchor">#</a> Arrow Declaration and <code>decltype</code></h2> <p>What if we allow using 2 types to calculate distance ?</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token operator">?</span> <span class="token function">distance2</span><span class="token punctuation">(</span>coordinate<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> c1<span class="token punctuation">,</span> coordinate<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span> c2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">sqr</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span>x <span class="token operator">-</span> c2<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">sqr</span><span class="token punctuation">(</span>c2<span class="token punctuation">.</span>y <span class="token operator">-</span> c2<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>So the function will look like this. Here <code>?</code> is <strong>not</strong> a  valid keyword. What should we put to replace <code>?</code>, in another word, what is the return type of the function ?</p> <p>Actually we have no idea, at least we don't know it while defining the function. For example, this how will we use the function.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>coordinate<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> c5 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
coordinate<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> c6 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3.3</span><span class="token punctuation">,</span> <span class="token number">4.4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
coordinate<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> c7 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">5.5</span><span class="token punctuation">,</span> <span class="token number">6.6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">distance2</span><span class="token punctuation">(</span>c5<span class="token punctuation">,</span> c6<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">distance2</span><span class="token punctuation">(</span>c6<span class="token punctuation">,</span> c7<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>The type of the first result (line 4) is <code>float</code>, the second one (line 5) is <code>double</code>.</p> <p>When will we know the type of the return value ? The answer is at the moment we use that template function in our code. Here, according to the instruction in the function and the type conversion rule, the calculation between <code>int</code> and <code>float</code> will have <code>float</code>, <code>float</code> with <code>double</code> is <code>double</code>. So the return type will be known, when compiler tries to generate a real function based on our template at compile time. That is to say, the compiler knows the return type. As result, we can tell the compiler <em>&quot; Hey, the return type is what you know when you compile it.&quot;</em></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// since C++11</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">distance2</span><span class="token punctuation">(</span>coordinate<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> c1<span class="token punctuation">,</span> coordinate<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span> c2<span class="token punctuation">)</span>
<span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">sqr</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span>x <span class="token operator">-</span> c2<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">sqr</span><span class="token punctuation">(</span>c2<span class="token punctuation">.</span>y <span class="token operator">-</span> c2<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">sqr</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span>x <span class="token operator">-</span> c2<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">sqr</span><span class="token punctuation">(</span>c2<span class="token punctuation">.</span>y <span class="token operator">-</span> c2<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>C++11</strong> introduced another syntax to declare a function, <strong>trailing return type</strong>. We can declare the return type after parameters with an <strong>arrow</strong>. Attention, in that case we need to write a <code>auto</code> at the old place just for valid syntax purpose.</p> <p><code>decltype</code> keyword is another C++11 feature. It accepts a expression and declares the type of that expression as a type. In our case, the type we need is the type of the distance formula. So we put it in the <code>decltype</code>. This is how we tell the compiler to use the type of the expression as the return type of the function.</p> <p>One would say, why can't I just use the old syntax, put the whole <code>decltype(...)</code> thing at the beginning of the function declaration. We can't, because, we used arguments in the expression, and at the beginning of the declaration, compiler don't know what are they. So we have to take the trailing version.</p> <p>This is a little tedious. We have written that expression in the return statement, why on the earth we have to write it again and specify that again. That's true, it's stupid, but it's not that stupid. So since <strong>C++14</strong>, we can be more concise.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// since C++14</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">distance3</span><span class="token punctuation">(</span>coordinate<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> c1<span class="token punctuation">,</span> coordinate<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span> c2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">sqr</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span>x <span class="token operator">-</span> c2<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">sqr</span><span class="token punctuation">(</span>c2<span class="token punctuation">.</span>y <span class="token operator">-</span> c2<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>decltype(auto)</code> tells the compiler <em>&quot; Figure out the type for us please and declare that type as the return type, we don't care what it is.&quot;</em>. The <code>auto</code> here does <strong>not</strong> have the same semantic as the one before. This one is for type deduction, the last one is to fit syntax.</p> <p>We have seem several examples of template programing in this chapter. Still, there a lot of tricks on templates. In the next chapter, we gonna learn the mechanism of <code>std::advance</code> and write one by ourselves.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/CPP-for-HPX/guide/Chapter01/" class="prev">
        Standard Template Library (STL)
      </a></span> <span class="next"><a href="/CPP-for-HPX/guide/Chapter03/">
        Template Meta-programing
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/CPP-for-HPX/assets/js/app.ee480cfc.js" defer></script><script src="/CPP-for-HPX/assets/js/2.c47d8a76.js" defer></script><script src="/CPP-for-HPX/assets/js/12.d5d0a49c.js" defer></script>
  </body>
</html>
