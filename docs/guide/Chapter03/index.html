<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Template Meta Programing | C++ for HPX</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/CPP-for-HPX/images/logo.png">
    <meta name="description" content="a tutorial of C++ for HPX">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/CPP-for-HPX/assets/css/0.styles.3599561d.css" as="style"><link rel="preload" href="/CPP-for-HPX/assets/js/app.17fff2da.js" as="script"><link rel="preload" href="/CPP-for-HPX/assets/js/2.c47d8a76.js" as="script"><link rel="preload" href="/CPP-for-HPX/assets/js/13.c0be51e4.js" as="script"><link rel="prefetch" href="/CPP-for-HPX/assets/js/10.f9b7d4f7.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/11.465437ef.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/12.4dc66af5.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/14.89d8e1e7.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/15.c739690a.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/16.55b19e29.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/17.c0c3b546.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/3.47b60fb2.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/4.9a2e6ff2.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/5.f862fe83.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/6.6e41bdef.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/7.dbf4b476.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/8.91f9e149.js"><link rel="prefetch" href="/CPP-for-HPX/assets/js/9.3f9464bc.js">
    <link rel="stylesheet" href="/CPP-for-HPX/assets/css/0.styles.3599561d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/CPP-for-HPX/" class="home-link router-link-active"><img src="/CPP-for-HPX/images/logo.png" alt="C++ for HPX" class="logo"> <span class="site-name can-hide">C++ for HPX</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/CPP-for-HPX/guide/" class="nav-link router-link-active">
  Guide
</a></div><div class="nav-item"><a href="/CPP-for-HPX/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://hpx-docs.stellar-group.org/latest/html/index.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  HPX
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/Wenke-D/CPP-for-HPX" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/CPP-for-HPX/guide/" class="nav-link router-link-active">
  Guide
</a></div><div class="nav-item"><a href="/CPP-for-HPX/config/" class="nav-link">
  Config
</a></div><div class="nav-item"><a href="https://hpx-docs.stellar-group.org/latest/html/index.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  HPX
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/Wenke-D/CPP-for-HPX" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Guide</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/CPP-for-HPX/guide/" aria-current="page" class="sidebar-link">Introduction</a></li><li><a href="/CPP-for-HPX/guide/Chapter01/" class="sidebar-link">Standard Template Library (STL)</a></li><li><a href="/CPP-for-HPX/guide/Chapter02/" class="sidebar-link">Template Programing</a></li><li><a href="/CPP-for-HPX/guide/Chapter03/" aria-current="page" class="active sidebar-link">Template Meta Programing</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/CPP-for-HPX/guide/Chapter03/#meta-function" class="sidebar-link">Meta Function</a></li><li class="sidebar-sub-header"><a href="/CPP-for-HPX/guide/Chapter03/#branch-and-specialization" class="sidebar-link">Branch and Specialization</a></li><li class="sidebar-sub-header"><a href="/CPP-for-HPX/guide/Chapter03/#type-computation" class="sidebar-link">Type Computation</a></li><li class="sidebar-sub-header"><a href="/CPP-for-HPX/guide/Chapter03/#true-type-and-false-type" class="sidebar-link">True Type and False Type</a></li><li class="sidebar-sub-header"><a href="/CPP-for-HPX/guide/Chapter03/#type-traits" class="sidebar-link">Type Traits</a></li><li class="sidebar-sub-header"><a href="/CPP-for-HPX/guide/Chapter03/#alias-by-typedef" class="sidebar-link">Alias by typedef</a></li></ul></li><li><a href="/CPP-for-HPX/guide/Chapter04/" class="sidebar-link">Exercise: my::advance</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="template-meta-programing"><a href="#template-meta-programing" class="header-anchor">#</a> Template Meta Programing</h1> <p>In the previous chapter, we presented the template system of C++, including template function and template class. About the template class, we implemented one named <code>coordinated&lt;T&gt;</code>. In this chapter we gonna still focus on template class.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">coordinate</span> <span class="token punctuation">{</span> T x<span class="token punctuation">,</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>This usage is what the template class was invented for, defining types based on various generic type, so that we could use it in different contexts. Almost every standard container, such as <code>std::vector</code>, <code>std::list</code>, is parametrizable with template type.</p> <p>The template become a C++ standard at 1998. Then a guy found something that template was not designed for. He discovered that template system is <strong>Turing-Complete</strong>. Loosely speaking, Turing-completeness means a system has the minimum set of necessary operations allowing the system to perform universal computation. The fact that template is turing complete means one can perform computation at compile time.</p> <p>This was surprising at that moment. That guy showed a program which printed prime numbers in the compiler generated error message during compile time, then the program failed to be compiled (which proved that the computation really happened at compile time). We call programing at compile time: <strong>template meta programing</strong>(TMP). This was the starting point of template meta programing ,and it completely went off today. One usage of the template meta-programing is the code generation during compile time, whose examples have been shown in previous chapters.</p> <p>At this chapter, as many examples we gonna use have a counterpart with the same name in standard template library under the namespace <code>std</code>, we will put our example under the namespace <code>my</code> to distinguish from them.</p> <h2 id="meta-function"><a href="#meta-function" class="header-anchor">#</a> Meta Function</h2> <p>First of all, let's see how to define and call functions in TMP. We will show a simple example of numerical computation, <strong>factorial</strong> calculation at compile time. For illustration purpose, we gonna do it in the old way (before C++11), some modern C++ features can simplify it, we will talk about them later.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">factorial</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">const</span> value <span class="token operator">=</span> N <span class="token operator">*</span> factorial<span class="token operator">&lt;</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// template specialization</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">factorial</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>We defined a template class named <code>factorial</code>. It takes an integer as template parameter instead of a type (line 1). This is valid, C++ allows us declaring <code>integer</code>, <code>long</code>, <code>bool</code> etc... as template parameter. So, for each integer argument, we will have a different type. For instances, <code>factorial&lt;1&gt;</code> and <code>factorial&lt;2&gt;</code> are 2 <strong>independent</strong> types. This allows us encoding integers into types.</p> <p>As result, we can use types to represent integers, and this is the basis for computation at compile time. Because the compiler can't do input, output nor assign variable. All we can do is to generate types as variables so that we could program. Since we can't change type, the variable is immutable. This feels like functional programing(FP), as we can't change the value of a variable in FP either.</p> <p>This is exactly how we are going to use template for computation. Whenever we need a new variable, we create a new type represent that variable. So calculating factorial is essentially creating a sequence of types representing each factorial when the factorial is unfolded recursively. So each time we multiple, we create a new type as the operand.</p> <p>In term of syntax, this is a template class, but we use it as a function. So we call it <strong>meta function</strong>, meta means that it runs at compile time. Now we can define parameters and pass arguments to it. But what is the return value of that function ? People have come up a pure convention for return value. For a meta function for numerical computation, we will <strong>always</strong> define a <code>static</code> member called <code>value</code> and make it <code>const</code> as a variable. In our case, the return value is integer, so the <code>value</code> is of type <code>int</code>. We get the return value of the meta function by access this member, for example <code>10!</code> is <code>factorial&lt;10&gt;::value</code>. As it's a convention, whenever seeing a template class with a <code>value</code> as its member, we could just assume the template class is meta function for numerical operations.</p> <h2 id="branch-and-specialization"><a href="#branch-and-specialization" class="header-anchor">#</a> Branch and Specialization</h2> <p>So in the body of the meta function, we use <code>N * factorial &lt;N-1&gt;::value</code> to recursively calculate the factorial of N. But this is not enough, we need to find a way to stop at <code>1!</code>, otherwise the compilation will never stop. In another world, we need to be able to make decision, so we need some thing like a <code>if</code> statement.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">factorial</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">const</span> value <span class="token operator">=</span> N <span class="token operator">*</span> factorial<span class="token operator">&lt;</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// template specialization</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">factorial</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>This is done by <strong>template specialization</strong> (line 6).
In addition to the main template, we supply another specialization of the template which will be used when the integer argument is equal to 1. Whenever we use <code>factorial&lt;1&gt;</code>, the compile will not use the main template but the specialization. This give us a break point, it will go down till N is equal to 1 and then go back to give us the final result.</p> <p>It's called specialization, because we provide special templates for one or more template arguments. For all other value, the compile still chooses the original template. We can provide as many template specializations as we want. The compile performs the pattern matching to find the one best matching the argument.</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>For some of you know functional programing, this is very similar to the following <code>ocaml</code> code.</p> <div class="language-ocaml line-numbers-mode"><pre class="language-ocaml"><code><span class="token keyword">let</span> <span class="token keyword">rec</span> factorial n <span class="token operator">=</span> <span class="token keyword">match</span> n <span class="token keyword">with</span>
  <span class="token operator">|</span><span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token number">1</span>
  <span class="token operator">|</span>x <span class="token operator">-&gt;</span> x <span class="token operator">*</span> factorial <span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">;;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></div> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>    cout <span class="token operator">&lt;&lt;</span> my<span class="token double-colon punctuation">::</span>factorial<span class="token operator">&lt;</span><span class="token number">10</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></code></pre> <div class="line-numbers-wrapper"></div></div><p>This is how we call the function in our code. After the compilation, the factorial&lt;10&gt;::value will become 3628800.</p> <p>For some of you who doubt that this is really happening at compile time? We can check the generated assembly code. The argument for g++ to generate assembly code is <code>-S</code>.</p> <div class="language-armasm line-numbers-mode"><div class="highlight-lines"><br><br><div class="highlighted"> </div><br><br><br></div><pre class="language-armasm"><code>	movl	<span class="token operator">%</span>edi<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">(</span><span class="token operator">%</span>rbp<span class="token punctuation">)</span>
	movq	<span class="token operator">%</span>rsi<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">(</span><span class="token operator">%</span>rbp<span class="token punctuation">)</span>
	movl	<span class="token variable">$3628800</span><span class="token punctuation">,</span> <span class="token operator">%</span>esi
	leaq	_ZSt4cout<span class="token punctuation">(</span><span class="token operator">%</span>rip<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rdi
	call	_ZNSolsEi@PLT
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>In our case, we can see there is no loop nor multiplication, the result is directly written in the assembly code (line 3).</p> <p>Template specialization is very powerful and we will use it over and over again. Besides, there are some limitation on the template argument. As we said, <code>int</code>, <code>long</code>, <code>bool</code> etc... can be template parameters, but we can't declare real numbers as template parameter, including <code>float</code>, <code>double</code> and their variants. Because they are not complete type, some numbers can't be represented precisely. Since the compiler use pattern matching to choose the template, we can't use have some template that may or may not be chosen. But nowadays, with <code>constexpr</code> (C++11), this becomes possible too, so a full complete programing at compile time. We will talk about it in detail in the future.</p> <h2 id="type-computation"><a href="#type-computation" class="header-anchor">#</a> Type Computation</h2> <p>Another thing we can do with meta function is type computation. Instead of calculations of some values, meta function can return a type.</p> <p>In certain scenarios, if we have a type, we want have its pointer type, such as getting <code>int*</code> from <code>int</code>. And we want that happened at compile time. We used some of these techniques in HPX. Because HPX is a very generic library. For example, <code>hpx::asnyc()</code> can work with arbitrary argument. Under the hood, there are a lot of type computations, so that it can run the right code depending on the input type.</p> <h3 id="adding-pointer"><a href="#adding-pointer" class="header-anchor">#</a> adding pointer</h3> <p>The first example is a meta function which takes a type <code>T</code> as argument and generate the type <code>T*</code>.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">add_pointer</span> <span class="token punctuation">{</span> <span class="token keyword">typedef</span> T <span class="token operator">*</span>type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>According to the convention, when a meta function is for type computation, the member for return value will be named <code>type</code>.</p> <p>As you can see , obviously when we have a T as argument, the return value of this function is T*.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>    my<span class="token double-colon punctuation">::</span>add_pointer<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type x1<span class="token punctuation">;</span></code></pre> <div class="line-numbers-wrapper"></div></div><p>The type of variable <code>x</code> is <code>int*</code> instead of <code>int</code>.
Also, one can use <code>typeid</code> keyword to retrieve information from a type.</p> <h3 id="making-map"><a href="#making-map" class="header-anchor">#</a> making map</h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">V</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">make_map</span> <span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>This meta function returns a concrete map type based on template argument.</p> <h3 id="removing-pointer"><a href="#removing-pointer" class="header-anchor">#</a> removing pointer</h3> <p>We had a <code>add_pointer</code>, how about <code>remove_pointer</code> which removes the star if the type is a pointer.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">remove_pointer</span> <span class="token punctuation">{</span> <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">remove_pointer</span><span class="token operator">&lt;</span>T <span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>This meta function, here we still need a condition to check whether the argument is a pointer type or, so we need template specialization.</p> <h3 id="no-pointer"><a href="#no-pointer" class="header-anchor">#</a> no pointer</h3> <p>How about a <code>no_pointer</code>, which removes all stars on a type recursively.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">no_pointer</span> <span class="token punctuation">{</span> <span class="token keyword">typedef</span> T type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">no_pointer</span><span class="token operator">&lt;</span>T <span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">my_no_pointer</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Here we applied the same technique as the factorial. we call the specialized meta function recursively as long as there is at least a star. Then we jump out the recursion by the main template.</p> <p>One thing we need to notice is the keyword <code>typename</code>, it hint the compile that the following expression is a type not a value, because in some cases, the compiler can't distinguish them. The compiler nowadays is good enough to tell if its needs that keyword or not.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>my<span class="token double-colon punctuation">::</span>no_pointer<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type x3<span class="token punctuation">;</span>
my<span class="token double-colon punctuation">::</span>no_pointer<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type x4<span class="token punctuation">;</span></code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>x3</code> and <code>x4</code> are of type <code>int</code> and <code>double</code> respectively.</p> <p>So we can do nice type transformation by pattern matching. That is, we can choose template based on our need, and template specialization is really the key to that.</p> <h3 id="partial-specialization"><a href="#partial-specialization" class="header-anchor">#</a> partial specialization</h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> flag<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">if_</span> <span class="token punctuation">{</span> <span class="token keyword">typedef</span> T1 type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">if_</span><span class="token operator">&lt;</span><span class="token boolean">false</span><span class="token punctuation">,</span> T1<span class="token punctuation">,</span> T2<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> T2 type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>This meta function returns T1 when flag is true, otherwise returns T2. The main template which will be selected whenever the flag is true. When the flag is false, the specialization will be used. Please notice that the template can be partially specialized. The specialization only specify the <strong>first</strong> parameter of the main template.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>my<span class="token double-colon punctuation">::</span>if_<span class="token operator">&lt;</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span> var1<span class="token punctuation">;</span>
my<span class="token double-colon punctuation">::</span>if_<span class="token operator">&lt;</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span> var2<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>var1</code> is of type <code>int</code>, and <code>var2</code> is a <code>bool</code>.</p> <p>We need to emphasize again that all the computations above happened at compile time.</p> <h2 id="true-type-and-false-type"><a href="#true-type-and-false-type" class="header-anchor">#</a> True Type and False Type</h2> <p>Now we want to introduce 2 facilities that are so useful, that they are in standard now.
A type representing boolean value <code>true</code>, and one for boolean value <code>false</code>.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">true_type</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> true_type type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">false_type</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">typedef</span> false_type type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>They are not template, simply structures. They are used to represent <code>true</code> and <code>false</code> in the type system. And since we want them to be true meta function, we not only give them a value but also a type as member. For lack of alternative, we just let them return themselves as the type. We can use them both for numerical computation and type computation. As you will see, these small tricks will be used everywhere.</p> <h2 id="type-traits"><a href="#type-traits" class="header-anchor">#</a> Type Traits</h2> <p>We already have meta functions for the numerical operation and type transformation, We can also have meta function for retrieving information from the type. For instance, the meta function <code>is_void&lt;T&gt;</code> to check if the <code>T</code> is <code>void</code> or not. These special meta function are called <strong>type traits</strong>, as they introspect the information of type.</p> <p>All type traits in standard library return <code>std::true_type</code> or <code>std::false_type</code>. We are going to show how to write some of them. In our version, it will return <code>my::true_type</code> or <code>my::true_type</code>.</p> <p>The first type traits is <code>is_pointer&lt;T&gt;</code>, it checks whether T is a pointer or not.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">is_pointer</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">false_type</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">is_pointer</span><span class="token operator">&lt;</span>T <span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token operator">:</span> true_type <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Essentially, we are making decision based on input, so the specialization shows itself again. The tricky part is how we gonna return <code>true_type</code> and <code>false_type</code>. We will use inherence, if <code>T</code> is a pointer, we gonna return <code>true_type</code> by deriving the meta function from <code>true_type</code>, otherwise deriving <code>false_type</code>. Whatever <code>true_type</code> / <code>false_type</code> have , the <code>is_pointer</code> will implicitly have it too. The reason this way works, is because essentially the meta funtion is template class.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>    my<span class="token double-colon punctuation">::</span>is_pointer<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">;</span></code></pre> <div class="line-numbers-wrapper"></div></div><p>The value of the above expression is <code>false</code>.</p> <p>Here's another example, a type traits takes 2 template types as arguments and check whether they are the same or not.</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">is_same</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">false_type</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">is_same</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">&gt;</span> <span class="token operator">:</span> true_type <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Again, the specialization is used for conditional return, and we use inherence for the return value.</p> <p>According to the convention, all standard type traits return <code>true_type</code> or <code>false_type</code>. Hence, next time when you see expressions like <code>is_xxx::type</code>, don't no need to digging in what it is. Because some them could be extremely complex, to query the information of type.
But, we can immediately know that it will give <code>true_type</code> or <code>false_type</code>. So, this is how we build the high level abstraction without understanding what is actually going on, and most of time we even don't want to understanding it because they are fairly trickly.</p> <p>A funny fact, early days, when Boots invented all these mechanisms, the compiler was weak, old, and not conforming to the standard. As consequences, some implementations of type traits toke advantage of compiler bugs to do its job. They knew for this particular compiler, if we do it that way, it will do exactly what we want and there is no other way.</p> <p>Type trait are widely used in HPX, for example <code>is_execution_policy</code>, we defined a lot customized ones in HPX to allow us inspecting the type for our own needs.</p> <h2 id="alias-by-typedef"><a href="#alias-by-typedef" class="header-anchor">#</a> Alias by <code>typedef</code></h2> <p>C++ has two ways to define type alias, <code>typedef</code> and <code>using</code>. <code>using</code> is a more powerful feature.
HPX uses <code>typedef</code> for backward compatibility, to support the compiler that doesn't know <code>using</code>. Once we get rid of GCC 4.6, 4.7, we will switch to the new way.</p> <p>We can't use <code>typedef</code> to defining template alisa, this is one reason that <code>using</code> was introduced.</p> <hr> <p>The next chapter is an exercise. We gonna write the function <code>std::advance</code> by ourselves. The exercise will revise all the techniques we've learned before.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/CPP-for-HPX/guide/Chapter02/" class="prev">
        Template Programing
      </a></span> <span class="next"><a href="/CPP-for-HPX/guide/Chapter04/">
        Exercise: my::advance
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/CPP-for-HPX/assets/js/app.17fff2da.js" defer></script><script src="/CPP-for-HPX/assets/js/2.c47d8a76.js" defer></script><script src="/CPP-for-HPX/assets/js/13.c0be51e4.js" defer></script>
  </body>
</html>
